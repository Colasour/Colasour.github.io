(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{306:function(e,v,_){"use strict";_.r(v);var t=_(35),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"frontmatter-title"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[e._v("#")]),e._v(" "+e._s(e.$frontmatter.title))]),e._v(" "),t("h2",{attrs:{id:"数据压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据压缩"}},[e._v("#")]),e._v(" 数据压缩")]),e._v(" "),t("p",[t("strong",[e._v("数据压缩")]),e._v(" 是最基本的解决传输大文件的方案，把大象变成小猪佩奇，再放进冰箱。")]),e._v(" "),t("p",[e._v("通常浏览器在发送请求时都会带着 "),t("code",[e._v("Accept-Encoding")]),e._v(" 头字段，里面是了起来支持的压缩格式列表，例如 "),t("code",[e._v("gzip")]),e._v("、"),t("code",[e._v("deflate")]),e._v("、"),t("code",[e._v("br")]),e._v(" 等，这样服务器就可以从中选择一种压缩算法，放进 "),t("code",[e._v("Content-Encoding")]),e._v(" 响应头里，再把原数据压缩后发送给浏览器。")]),e._v(" "),t("p",[e._v("不过这个解决方法也有个缺点，"),t("code",[e._v("gzip")]),e._v(" 等压缩算法通常只对"),t("em",[e._v("文本文件")]),e._v("有较好的压缩率、而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 "),t("code",[e._v("gzip")]),e._v(" 处理也不会变小（甚至还有可能增大一点），所以它就失效了。")]),e._v(" "),t("h2",{attrs:{id:"分块传输"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分块传输"}},[e._v("#")]),e._v(" 分块传输")]),e._v(" "),t("p",[t("strong",[e._v("压缩")]),e._v("是把大文件整体变小，反过来思考，如果大文件整体不能变小，那就把它“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。")]),e._v(" "),t("p",[e._v("这样浏览器和服务器都不用在内存里保存文件的全部，每次只收发一小部分，网络也不会被大文件长时间占用，内存、带宽等资源也就节省下来了。")]),e._v(" "),t("p",[e._v("这种"),t("strong",[e._v("化整为零")]),e._v("的思路在 HTTP 协议里就是 "),t("code",[e._v("chunked")]),e._v(" 分块传输编码，在响应报文里用头字段 "),t("code",[e._v("Transfer-Encoding: chunked")]),e._v(" 表示，意思是报文里的 "),t("code",[e._v("body")]),e._v(" 部分不是一次性发过来的，而是分成了许多的块 (chunk) 逐个发送。")]),e._v(" "),t("p",[e._v("分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 "),t("code",[e._v("body")]),e._v(" 数据的长度是未知的，无法在头字段 "),t("code",[e._v("Content-Length")]),e._v(" 里给出确切的长度，所以也只能用 "),t("code",[e._v("chunked")]),e._v(" 方式分块发送。")]),e._v(" "),t("p",[t("code",[e._v("Transfer-Encoding: chuncked")]),e._v(" 和 "),t("code",[e._v("Content-Length")]),e._v(" 这两个字段是"),t("strong",[e._v("互斥的")]),e._v("，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知 (chunked)。")]),e._v(" "),t("p",[e._v("分块传输的规则，采用了明文的方式，类似响应头：")]),e._v(" "),t("ol",[t("li",[e._v("每个分块包含两个部分，"),t("strong",[e._v("长度头")]),e._v("和"),t("strong",[e._v("数据块")])]),e._v(" "),t("li",[e._v("长度头是以 "),t("code",[e._v("CRLF")]),e._v(" 结尾的一行明文，用 16 进制数字表示长度")]),e._v(" "),t("li",[e._v("数据块紧跟在长度头后，最后也用 "),t("code",[e._v("CRLF")]),e._v(" 结尾，但数据不包含 "),t("code",[e._v("CRLF")])]),e._v(" "),t("li",[e._v("最后用一个长度为 "),t("code",[e._v("0")]),e._v(" 的块表示结束，即 "),t("code",[e._v("0\\r\\n\\r\\n")])])]),e._v(" "),t("p",[t("img",{attrs:{src:_(521),alt:"chunked"}})]),e._v(" "),t("p",[t("img",{attrs:{src:_(522),alt:"chunked1"}})]),e._v(" "),t("h2",{attrs:{id:"范围请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#范围请求"}},[e._v("#")]),e._v(" 范围请求")]),e._v(" "),t("p",[e._v("有了分块传输编码，服务器可以轻松地收发大文件，但对于上 G 的超大文件，还有一些问题需要考虑。")]),e._v(" "),t("p",[e._v("比如，在看当下热播的某剧时，想跳过片头、直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获得一个大文件其中的片段数据，而分块传输并没有这个能力。")]),e._v(" "),t("p",[e._v("HTTP 协议为了满足这样的需求，提出了 "),t("strong",[e._v("范围请求 (range requests)")]),e._v(" 的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的"),t("strong",[e._v("化整为零")]),e._v("。")]),e._v(" "),t("p",[e._v("范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段 "),t("code",[e._v("Accept-Ranges: bytes")]),e._v(" 明确告知客户端：“我是支持范围请求的”。")]),e._v(" "),t("p",[e._v("服务器发送 "),t("code",[e._v("Accept-Ranges: none")]),e._v("，或者干脆不发送 "),t("code",[e._v("Accept-Ranges")]),e._v(" 字段，这样客户端就认为服务器没有实现范围请求功能。")]),e._v(" "),t("h3",{attrs:{id:"请求头-range"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求头-range"}},[e._v("#")]),e._v(" 请求头 Range")]),e._v(" "),t("p",[e._v("请求头 "),t("strong",[e._v("Range")]),e._v(" 是 HTTP 范围请求的专用字段，格式是 "),t("code",[e._v("bytes=x-y")]),e._v("，其中的 "),t("code",[e._v("x")]),e._v(" 和 "),t("code",[e._v("y")]),e._v(" 是以字节为单位的数据范围。")]),e._v(" "),t("p",[e._v("Range 的格式也很灵活，起点 "),t("code",[e._v("x")]),e._v(" 和终点 "),t("code",[e._v("y")]),e._v(" 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("0-")]),e._v(" 表示从文档到文档终点，相当于 0-99，即整个文件")]),e._v(" "),t("li",[t("code",[e._v("10-")]),e._v(" 是从第 10 个字节开始到文档末尾，相当于 10-99")]),e._v(" "),t("li",[t("code",[e._v("-1")]),e._v(" 是文档的最后 1 个字节，相当于 99-99")]),e._v(" "),t("li",[t("code",[e._v("-10")]),e._v(" 是文档末尾倒数 10 个字节，相当于 90-99")])]),e._v(" "),t("p",[e._v("服务器收到 "),t("code",[e._v("Range")]),e._v(" 字段后，需要做四件事：")]),e._v(" "),t("ol",[t("li",[e._v("检查范围是否合法，比如文件只有 100 个字节，但请求 200-300，范围越界，返回状态码 "),t("code",[e._v("416 Range Not Satisfiable")])]),e._v(" "),t("li",[e._v("如果范围正确，服务器就可以根据 "),t("code",[e._v("Range")]),e._v(" 头计算偏移量，读取文件的片段，返回状态码 "),t("code",[e._v("206 Partial Content")])]),e._v(" "),t("li",[e._v("服务器要添加一个响应头字段 "),t("code",[e._v("Content-Range")]),e._v("，告诉片段的实际偏移量和资源的总大小，格式是 "),t("code",[e._v("bytes x-y/length")]),e._v("，与 "),t("code",[e._v("Range")]),e._v(" 头区别在没有 "),t("code",[e._v("=")]),e._v("，范围后多了总长度。例如，对于 0-10 的范围请求，值就是 "),t("code",[e._v("bytes 0-10/100")])]),e._v(" "),t("li",[e._v("最后发送数据，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完")])]),e._v(" "),t("div",{staticClass:"language-http extra-class"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[t("span",{pre:!0,attrs:{class:"token request-line"}},[t("span",{pre:!0,attrs:{class:"token property"}},[e._v("GET")]),e._v(" /16-2 HTTP/1.1")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Host:")]),e._v(" www.chrono.com\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Range:")]),e._v(" bytes=0-31\n")])])]),t("div",{staticClass:"language-http extra-class"},[t("pre",{pre:!0,attrs:{class:"language-http"}},[t("code",[t("span",{pre:!0,attrs:{class:"token response-status"}},[e._v("HTTP/1.1 "),t("span",{pre:!0,attrs:{class:"token property"}},[e._v("206 Partial Content")])]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Content-Length:")]),e._v(" 32\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Accept-Ranges:")]),e._v(" bytes\n"),t("span",{pre:!0,attrs:{class:"token header-name keyword"}},[e._v("Content-Range:")]),e._v(" bytes 0-31/96\n\n...this is a plain text json doc\n")])])]),t("p",[e._v("有了范围请求之后，HTTP 处理大文件就更轻松了，看视频是可以根据时间点计算出文件的 "),t("code",[e._v("Range")]),e._v("，不用下载整个文件，直接精确获取片段所在的数据内容。")]),e._v(" "),t("p",[e._v("不仅看视频的拖拽进度需要范围请求，常用的下案子工具里的多段下载、断点续传也是基于它实现的，要点是：")]),e._v(" "),t("ul",[t("li",[e._v("先发个 "),t("code",[e._v("HEAD")]),e._v("，看服务器是否支持范围请求，同时获取文件的大小")]),e._v(" "),t("li",[e._v("开 N 个线程，每个线程使用 "),t("code",[e._v("Range")]),e._v(" 字段划分出各自负责下载的片段，发请求传输数据")]),e._v(" "),t("li",[e._v("下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分即可")])]),e._v(" "),t("h3",{attrs:{id:"多段数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多段数据"}},[e._v("#")]),e._v(" 多段数据")]),e._v(" "),t("p",[e._v("范围请求不止只获取一个片段，它还支持在 "),t("code",[e._v("Range")]),e._v(" 头里使用多个 "),t("code",[e._v("x-y")]),e._v("，一次性获取多个片段数据。")]),e._v(" "),t("p",[e._v("这种情况需要使用一种特殊的 MIME 类型："),t("code",[e._v("multipart/byteranges")]),e._v("，表示报文的 "),t("code",[e._v("body")]),e._v(" 是由多段字节序列组成的，并且还要用一个参数 "),t("code",[e._v("boundary=xxx")]),e._v(" 给出段之间的分隔标记。")]),e._v(" "),t("p",[e._v("多段数据的格式与分块传输也比较类似，但它需要用分隔标记 "),t("code",[e._v("boundary")]),e._v(" 来区分不同的片段：")]),e._v(" "),t("p",[t("img",{attrs:{src:_(523),alt:"multipart ranges"}})]),e._v(" "),t("p",[e._v("每一个分段必须以 "),t("code",[e._v("--boundary")]),e._v(" 开始，之后要用 "),t("code",[e._v("Content-Type")]),e._v(" 和  "),t("code",[e._v("Content-Range")]),e._v(" 标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个 "),t("code",[e._v("--boundary--")]),e._v(" 表示所有的分段结束。")])])}),[],!1,null,null,null);v.default=a.exports},521:function(e,v,_){e.exports=_.p+"assets/img/chunked.25e7b09c.png"},522:function(e,v,_){e.exports=_.p+"assets/img/chunked1.e183bf93.png"},523:function(e,v,_){e.exports=_.p+"assets/img/multipart_ranges.fffa3a65.png"}}]);