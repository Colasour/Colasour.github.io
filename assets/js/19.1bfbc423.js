(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{313:function(v,_,t){"use strict";t.r(_);var r=t(35),e=Object(r.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h1",{attrs:{id:"frontmatter-title"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[v._v("#")]),v._v(" "+v._s(v.$frontmatter.title))]),v._v(" "),r("h2",{attrs:{id:"http-代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-代理"}},[v._v("#")]),v._v(" HTTP 代理")]),v._v(" "),r("p",[v._v("引入 HTTP 代理后，原来简单的双方通信就变复杂了一些，加入了一个或者多个中间人，但整体上来看，还是一个有顺序关系的链条，而且链条里相邻的两个角色仍然是简单的一对一通信，不会出现越级的情况。")]),v._v(" "),r("p",[r("img",{attrs:{src:t(540),alt:"代理"}})]),v._v(" "),r("p",[v._v("链条的起点还是客户端（也就是浏览器），中间的橘色被称为"),r("strong",[v._v("代理服务器 (proxy server)")]),v._v("，链条的终点被称为"),r("strong",[v._v("源服务器 (origin server)")]),v._v("，意思是数据的“源头”。")]),v._v(" "),r("h2",{attrs:{id:"代理服务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理服务"}},[v._v("#")]),v._v(" 代理服务")]),v._v(" "),r("p",[v._v("HTTP 代理就是在客户端和服务器原本的通信链路中插入一个中间环节，也是一台服务器，但提供的是“代理服务”。")]),v._v(" "),r("p",[v._v("所谓的代理服务就是指服务本身不产生内容，而是处于中间位置转发上下游的请求和响应，具有双重身份；面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；面向上游的源服务器时，表现为客户端，代表客户端发送请求。")]),v._v(" "),r("h2",{attrs:{id:"代理的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理的作用"}},[v._v("#")]),v._v(" 代理的作用")]),v._v(" "),r("p",[v._v("由于代理处在 HTTP  通信过程的中间位置，相应地就对上屏蔽了真实客户端，对下屏蔽了真实服务器。")]),v._v(" "),r("h3",{attrs:{id:"复杂均衡"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复杂均衡"}},[v._v("#")]),v._v(" 复杂均衡")]),v._v(" "),r("p",[v._v("代理最基本的一个功能是"),r("strong",[v._v("负载均衡")]),v._v("。因为在面向客户端时屏蔽了源服务器，客户端看到的知识代理服务器，源服务器究竟有多少台、是哪些 IP 地址都不知道。于是代理服务器就可以掌握请求分发的“权力”，决定由后面的哪台服务器来响应请求。")]),v._v(" "),r("p",[r("img",{attrs:{src:t(541),alt:"反向代理"}})]),v._v(" "),r("p",[v._v("代理中常用的负载均衡算法如轮询、一致性哈希等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能。")]),v._v(" "),r("p",[v._v("在负载均衡的同时，代理服务还可以执行更多的功能，比如：")]),v._v(" "),r("ul",[r("li",[r("strong",[v._v("健康检查")]),v._v("：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用")]),v._v(" "),r("li",[r("strong",[v._v("安全防护")]),v._v("：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载")]),v._v(" "),r("li",[r("strong",[v._v("加密卸载")]),v._v("：对外网使用 "),r("code",[v._v("SSL/TLS")]),v._v(" 加密通信认证，而在安全的内网不加密，消除加密成本")]),v._v(" "),r("li",[r("strong",[v._v("数据过滤")]),v._v("：拦截上下行的数据，任意指定策略修改请求或者响应")]),v._v(" "),r("li",[r("strong",[v._v("内容缓存")]),v._v("：暂存、复用服务器响应")])]),v._v(" "),r("h2",{attrs:{id:"代理相关头字段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理相关头字段"}},[v._v("#")]),v._v(" 代理相关头字段")]),v._v(" "),r("h3",{attrs:{id:"via"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#via"}},[v._v("#")]),v._v(" Via")]),v._v(" "),r("p",[r("code",[v._v("Via")]),v._v(" 是一个通用字段，请求头或响应头都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾。如果通信链路中有很多中间代理，就会在 "),r("code",[v._v("Via")]),v._v(" 里形成一个链表，这样就可以知道报文究竟走过了多少个环节才到达了目的地。")]),v._v(" "),r("p",[r("img",{attrs:{src:t(542),alt:"Via"}})]),v._v(" "),r("p",[r("code",[v._v("Via")]),v._v(" 字段只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息。但服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道。不过反过来，通常服务器需要知道括号端的真实 IP 地址，方便做访问控制、用户画像、统计分析。")]),v._v(" "),r("p",[v._v("可惜的是 HTTP 标准里并没有为此定义头字段，但已经出现了很多“事实上的标准”，最常用的两个头字段是 "),r("code",[v._v("X-Forwarded-For")]),v._v(" 和 "),r("code",[v._v("X-Real-IP")]),v._v("。")]),v._v(" "),r("p",[r("code",[v._v("X-Forwarded-For")]),v._v(" 的字面意思是“为谁而转发”，形式上和 "),r("code",[v._v("Via")]),v._v(" 差不多，也是每经过一个代理节点就会在字段里追加一个信息。但 "),r("code",[v._v("Via")]),v._v(" 追加的是代理主机名（或者域名），而 "),r("code",[v._v("X-Forwarded-For")]),v._v(" 追加的请求方的 IP 地址。")]),v._v(" "),r("p",[r("code",[v._v("X-Real-IP")]),v._v(" 是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP 地址，没有中间的代理信息，相当于是 "),r("code",[v._v("X-Forwarded-For")]),v._v(" 的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值是相同的。")]),v._v(" "),r("p",[v._v("以实验环境为例，模拟实现一个反向代理，访问 "),r("code",[v._v("http://www.chrono.com/21-1")]),v._v("，它会转而访问 "),r("code",[v._v("http://origin.io")]),v._v("。这里的 "),r("code",[v._v("origin.io")]),v._v(" 就是源贴，它会在响应报文里输出 "),r("code",[v._v("Via")]),v._v("、"),r("code",[v._v("X-Forwarded-For")]),v._v(" 等代理头字段信息：")]),v._v(" "),r("p",[r("img",{attrs:{src:t(543),alt:"反向代理1"}})]),v._v(" "),r("p",[v._v("单从浏览器的页面上很难看出代理做了哪些工作，因为代理的阻焊发都在后台不可见，所以在这个过程用 Wireshark 抓了一个包：")]),v._v(" "),r("p",[r("img",{attrs:{src:t(544),alt:"反向代理2"}})]),v._v(" "),r("p",[v._v("从抓包里可以清晰地看出代理与客户端、源服务器的通信过程：")]),v._v(" "),r("ol",[r("li",[v._v("客户端 "),r("code",[v._v("55061")]),v._v(" 先用三次握手连接到代理的 "),r("code",[v._v("80")]),v._v(" 端口，然后发送 "),r("code",[v._v("GET")]),v._v(" 请求")]),v._v(" "),r("li",[v._v("代理不直接产生内容，所以就代表客户端，用 "),r("code",[v._v("55063")]),v._v(" 端口连接到源服务器，也是三次握手")]),v._v(" "),r("li",[v._v("代理成功连接源服务器后，发出了一个 "),r("code",[v._v("HTTP/1.0")]),v._v(" 的 "),r("code",[v._v("GET")]),v._v(" 请求")]),v._v(" "),r("li",[v._v("因为 "),r("code",[v._v("HTTP/1.0")]),v._v(" 默认是短连接，所以源服务器发送响应报文后立即用四次挥手关闭连接")]),v._v(" "),r("li",[v._v("代理拿到响应报文后再发回给客户端，完成了一次代理服务")])]),v._v(" "),r("h2",{attrs:{id:"代理协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理协议"}},[v._v("#")]),v._v(" 代理协议")]),v._v(" "),r("p",[v._v("有了 "),r("code",[v._v("X-Forwarded-For")]),v._v(" 等头字段，源服务器就可以拿到准确的客户端信息，但对于代理服务器来说它并不是一个最佳的解决方案。因为通过 "),r("code",[v._v("X-Forwarded-For")]),v._v(" 操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息，现在却必须要费力解析数据再修改数据，会降低代理的准发性能。")]),v._v(" "),r("p",[v._v("另一个问题是 "),r("code",[v._v("X-Forwarded-For")]),v._v(" 等头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。所以就促会先了一个专门的“"),r("strong",[v._v("代理协议 (The PROXY protocol)")]),v._v("”，它由知名的代理软件 HAProxy 所定义，也是一个“事实标准”，被广泛采用。代理协议有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文；而 v2 是二进制格式。")]),v._v(" "),r("p",[v._v("v1 版本在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。这一行文本非常简单，开始必须是 "),r("code",[v._v("PROXY")]),v._v(" 五个大写字母，然后是 "),r("code",[v._v("TCP4")]),v._v(" 或者 "),r("code",[v._v("TCP6")]),v._v("，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行 "),r("code",[v._v("\\r\\n")]),v._v(" 结束。")]),v._v(" "),r("div",{staticClass:"language-http extra-class"},[r("pre",{pre:!0,attrs:{class:"language-http"}},[r("code",[v._v("PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\nGET / HTTP/1.1\n"),r("span",{pre:!0,attrs:{class:"token header-name keyword"}},[v._v("Host:")]),v._v(" www.xxx.com\n\n...\n")])])]),r("p",[v._v("服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的 HTTP 数据。")]),v._v(" "),r("p",[v._v("不过代理协议并不支持 "),r("code",[v._v("X-Forwarded-For")]),v._v(" 的链式地址形式，所以拿到客户端地址后再如何处理就需要代理服务器与后端自行约定。")])])}),[],!1,null,null,null);_.default=e.exports},540:function(v,_,t){v.exports=t.p+"assets/img/proxy.28237ef9.png"},541:function(v,_,t){v.exports=t.p+"assets/img/reverse_proxy.8c1fe47a.png"},542:function(v,_,t){v.exports=t.p+"assets/img/via.52a3bd76.png"},543:function(v,_,t){v.exports=t.p+"assets/img/reverse_proxy1.c5aa6d5f.png"},544:function(v,_,t){v.exports=t.p+"assets/img/reverse_proxy2.5a247e9e.png"}}]);